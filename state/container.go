//
// Copyright 2019-2020 Nestybox, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package state

import (
	"fmt"
	"sync"
	"time"

	"github.com/nestybox/sysbox-fs/domain"
)

//
// Container type to represent all the container-state relevant to sysbox-fs.
//
type container struct {
	sync.RWMutex
	id            string                            // container-id value generated by runC
	initPid       uint32                            // initPid within container
	ctime         time.Time                         // container creation time
	uidFirst      uint32                            // first value of Uid range (host side)
	uidSize       uint32                            // Uid range size
	gidFirst      uint32                            // first value of Gid range (host side)
	gidSize       uint32                            // Gid range size
	procRoPaths   []string                          // OCI spec read-only proc paths
	procMaskPaths []string                          // OCI spec masked proc paths
	specPaths     map[string]struct{}               // OCI spec hashmap including all paths
	dataStore     domain.StateDataMap               // Handler's container-specific storage blob
	initProc      domain.ProcessIface               // container's init process
	service       domain.ContainerStateServiceIface // backpointer to service
}

//
// Getters implementations.
//

func (c *container) ID() string {
	c.RLock()
	defer c.RUnlock()

	return c.id
}

func (c *container) InitPid() uint32 {
	c.RLock()
	defer c.RUnlock()

	return c.initPid
}

func (c *container) Ctime() time.Time {
	c.RLock()
	defer c.RUnlock()

	return c.ctime
}

func (c *container) UID() uint32 {
	c.RLock()
	defer c.RUnlock()

	return c.uidFirst
}

func (c *container) GID() uint32 {
	c.RLock()
	defer c.RUnlock()

	return c.gidFirst
}

func (c *container) ProcRoPaths() []string {
	c.RLock()
	defer c.RUnlock()

	return c.procRoPaths
}

func (c *container) ProcMaskPaths() []string {
	c.RLock()
	defer c.RUnlock()

	return c.procMaskPaths
}

func (c *container) IsSpecPath(s string) bool {
	c.RLock()
	defer c.RUnlock()

	_, ok := c.specPaths[s]
	if !ok {
		return false
	}

	return true
}

func (c *container) Data(path string, name string) (string, bool) {
	c.RLock()
	defer c.RUnlock()

	if c.dataStore == nil {
		return "", false
	}

	if _, ok := c.dataStore[path]; !ok {
		return "", false
	}

	return c.dataStore[path][name], true
}

func (c *container) InitProc() domain.ProcessIface {
	c.RLock()
	defer c.RUnlock()

	return c.initProc
}

func (c *container) String() string {
	c.RLock()
	defer c.RUnlock()

	return fmt.Sprintf("id = %s, initPid = %d, uid:gid = %v:%v",
		c.id, int(c.initPid), c.uidFirst, c.gidFirst)
}

//
// Setters implementations.
//

func (c *container) update(src *container) error {
	c.Lock()
	defer c.Unlock()

	if c.initPid != src.initPid {
		// Initialize initProc.
		c.initProc = src.service.ProcessService().ProcessCreate(
			src.initPid,
			src.uidFirst,
			src.gidFirst,
		)
		c.initPid = src.initPid
	}

	if c.ctime != src.ctime {
		c.ctime = src.ctime
	}

	if c.uidFirst != src.uidFirst {
		c.uidFirst = src.uidFirst
	}

	if c.uidSize != src.uidSize {
		c.uidSize = src.uidSize
	}

	if c.gidFirst != src.gidFirst {
		c.gidFirst = src.gidFirst
	}

	if c.gidSize != src.gidSize {
		c.gidSize = src.gidSize
	}

	// Unconditional malloc + copy -- think about how to optimize if no changes
	// are detected.
	c.procRoPaths = make([]string, len(src.procRoPaths))
	copy(c.procRoPaths, src.procRoPaths)
	c.procMaskPaths = make([]string, len(src.procMaskPaths))
	copy(c.procMaskPaths, src.procMaskPaths)

	return nil
}

func (c *container) SetCtime(t time.Time) {
	c.Lock()
	defer c.Unlock()

	c.ctime = t
}

func (c *container) SetData(path string, name string, data string) {
	c.Lock()
	defer c.Unlock()

	if c.dataStore == nil {
		c.dataStore = make(domain.StateDataMap)
	}

	if _, ok := c.dataStore[path]; !ok {
		c.dataStore[path] = make(domain.StateData)
	}

	c.dataStore[path][name] = data
}

// Exclusively utilized for unit-testing purposes.
func (c *container) SetInitProc(pid, uid, gid uint32) error {
	if c.service == nil {
		return fmt.Errorf("No css service identified")
	}

	if c.service.ProcessService() == nil {
		return fmt.Errorf("No pts service identified")
	}

	c.initProc = c.service.ProcessService().ProcessCreate(pid, uid, gid)

	return nil
}

// Exclusively utilized for unit-testing purposes.
func (c *container) SetService(css domain.ContainerStateServiceIface) {
	c.service = css
}
